#indent 4

#if[target=wasm&wasix]
#extern "wasix_32v1" "tty_get" fn wasix_tty_get <(i32)*>i32>
#if[target=wasm&wasix]
#extern "wasix_32v1" "tty_set" fn wasix_tty_set <(i32)*>i32>

#import "core/mem" as *
#import "core/math" as *
#import "alloc/string" as *
#import "alloc/vec" as *

//: wasix/tui: WASIX 端末制御と TUI 描画補助ライブラリ
//:
//: [目的/もくてき]:
//: - WASIX の `tty_get` / `tty_set` を使って端末状態を取得・更新します。
//: - ANSI エスケープシーケンスを用いたカーソル移動・色制御を提供します。
//: - 行バッファを使った差分レンダリング機能を提供し、再描画コストを削減します。
//:
//: [実装/じっそう]:
//: - 端末状態は WASIX ABI の `Tty` 構造体レイアウトに合わせてメモリ上で操作します。
//: - 行バッファは `curr` と `prev` の2面を比較し、差分行のみ `print` します。
//: - 文字列の表示幅は UTF-8 先頭バイトを用いて概算し、ANSI/OSC8 制御列は幅0として扱います。
//:
//: [注意/ちゅうい]:
//: - 表示幅計算は厳密な East Asian Width 判定ではなく、実用上の近似です。
//: - 端末依存の表示差（フォント、絵文字幅、結合文字など）は吸収しきれません。
//: - 差分判定は行単位です。1文字だけの更新でも、その行全体を再出力します。

//: TtyState: WASIX TTY 構造体のメモリレイアウト
//: 
//: 目的:
//: - WASIX ABI の `Tty` 構造体を扱います。
//:
//: レイアウト:
//: - offset 0: cols (u32)
//: - offset 4: rows (u32)
//: - offset 8: width (u32)
//: - offset 12: height (u32)
//: - offset 16: stdin_tty (u8/bool)
//: - offset 17: stdout_tty (u8/bool)
//: - offset 18: stderr_tty (u8/bool)
//: - offset 19: echo (u8/bool)
//: - offset 20: line_buffered (u8/bool)
//: - (24 bytes allocated for safety)

fn get_tty_state <()*>i32> ():
    let ptr <i32> alloc 24;
    let errno <i32> wasix_tty_get ptr;
    if:
        eq errno 0
        then:
            ptr
        else:
            dealloc ptr 24;
            0

fn set_tty_state <(i32)*>i32> (ptr):
    wasix_tty_set ptr

fn get_cols <(i32)*>i32> (ptr):
    load_i32 ptr

fn get_rows <(i32)*>i32> (ptr):
    load_i32 add ptr 4

fn set_echo <(i32,bool)*>()> (ptr, enable):
    let v <i32> if enable 1 0;
    store_u8 add ptr 19 v

fn set_line_buffered <(i32,bool)*>()> (ptr, enable):
    let v <i32> if enable 1 0;
    store_u8 add ptr 20 v

//: enter_raw_mode: ターミナルを RAW モードにする
//:
//: 目的:
//: - echo と line_buffered を無効化します。
//: - 成功時は以前の TtyState ポインタを返します。
//:
//: 注意(重要):
//: - 返されたポインタは restore_mode に渡して解放する必要があります。
fn enter_raw_mode <()*>i32> ():
    let state <i32> get_tty_state;
    if:
        ne state 0
        then:
            let old_state <i32> alloc 24;
            // Copy state to old_state
            let mut i <i32> 0;
            while lt i 24:
                do:
                    store_u8 add old_state i load_u8 add state i;
                    set i add i 1;

            set_echo state false;
            set_line_buffered state false;
            let errno <i32> set_tty_state state;
            dealloc state 24;
            if:
                eq errno 0
                then:
                    old_state
                else:
                    dealloc old_state 24;
                    0
        else:
            0

//: restore_mode: ターミナルの状態を元に戻す
//:
//: 目的:
//: - enter_raw_mode で保存した状態を復元します。
fn restore_mode <(i32)*>i32> (old_state):
    if:
        ne old_state 0
        then:
            let errno <i32> set_tty_state old_state;
            dealloc old_state 24;
            errno
        else:
            -1

//: get_terminal_size: ターミナルのサイズ (cols, rows) を取得する
//:
//: 目的:
//: - 現在のターミナルの列数と行数を取得します。
fn get_terminal_size <()*>.Pair> ():
    let state <i32> get_tty_state;
    if:
        ne state 0
        then:
            let c <i32> get_cols state;
            let r <i32> get_rows state;
            dealloc state 24;
            Tuple:
                c
                r
        else:
            Tuple:
                0
                0

//: --- ANSI 画面制御ヘルパー ---

//: clear_screen: 画面全体をクリアしてカーソルを左上に移動する
fn clear_screen <()*>()> ():
    print "\x1b[2J\x1b[H";
    ()

//: move_cursor: カーソルを (col, row) に移動する (1-indexed)
fn move_cursor <(i32,i32)*>()> (col, row):
    print "\x1b[";
    print_i32 row;
    print ";";
    print_i32 col;
    print "H";
    ()

//: cursor_home: カーソルを左上 (1,1) に移動する
fn cursor_home <()*>()> ():
    print "\x1b[H";
    ()

//: hide_cursor: カーソルを非表示にする
fn hide_cursor <()*>()> ():
    print "\x1b[?25l";
    ()

//: show_cursor: カーソルを再表示する
fn show_cursor <()*>()> ():
    print "\x1b[?25h";
    ()

//: clear_line: カーソル行を消去する
fn clear_line <()*>()> ():
    print "\x1b[2K\r";
    ()

//: set_bg_color: 背景色を設定する (0-7: 標準色)
//: 0=黒 1=赤 2=緑 3=黄 4=青 5=マゼンタ 6=シアン 7=白
fn set_bg_color <(i32)*>()> (code):
    print "\x1b[";
    print_i32 add code 40;
    print "m";
    ()

//: set_fg_color: 前景色を設定する (0-7: 標準色)
fn set_fg_color <(i32)*>()> (code):
    print "\x1b[";
    print_i32 add code 30;
    print "m";
    ()

//: reset_color: 前景色と背景色をリセットする
fn reset_color <()*>()> ():
    print "\x1b[0m";
    ()

//: repeat_text: 文字列を指定回数だけ連結して返す
//:
//: [目的/もくてき]:
//: - 罫線や空白など、同じ文字列を繰り返す行生成を簡潔に記述します。
//:
//: [実装/じっそう]:
//: - `out` に対して `concat out s` を n 回繰り返します。
//:
//: [注意/ちゅうい]:
//: - `concat` の繰り返しなので、長大文字列ではコストが大きくなります。
//:
//: [計算量/けいさんりょう]:
//: - O(n^2)（文字列再確保の影響を含む）
fn repeat_text <(str,i32)*>str> (s, n):
    if:
        lt n 1
        then:
            ""
        else:
            let mut out <str> "";
            let mut i <i32> 0;
            while lt i n:
                do:
                    set out concat out s;
                    set i add i 1;
            out

//: str_display_width: 文字列の表示幅を概算する
//:
//: [目的/もくてき]:
//: - 行の右パディングを行う際に、日本語を含む表示の崩れを減らします。
//:
//: [実装/じっそう]:
//: - UTF-8 の先頭バイトから文字境界を推定し、ASCII は幅1、非ASCIIは幅2で加算します。
//: - ANSI CSI（`ESC [`）と OSC8（`ESC ] ... ESC \\`）は幅0としてスキップします。
//:
//: [注意/ちゅうい]:
//: - 厳密な文字幅計算ではなく、端末依存差を含む近似です。
//: - ゼロ幅結合や一部絵文字の幅は環境ごとに差が出ます。
//:
//: [計算量/けいさんりょう]:
//: - O(n)
fn str_display_width <(str)*>i32> (s):
    let n <i32> len s;
    let mut i <i32> 0;
    let mut w <i32> 0;
    while lt i n:
        do:
            let b <i32> load_u8 add s add 4 i;
            if:
                eq b 27
                then:
                    if:
                        lt add i 1 n
                        then:
                            let n1 <i32> load_u8 add s add 4 add i 1;
                            // CSI: ESC [ ... final(0x40-0x7e)
                            if:
                                eq n1 91
                                then:
                                    set i add i 2;
                                    let mut done <bool> false;
                                    while and lt i n not done:
                                        do:
                                            let c <i32> load_u8 add s add 4 i;
                                            if:
                                                and not lt c 64 lt c 127
                                                then:
                                                    set done true
                                                else:
                                                    ();
                                            set i add i 1;
                                else:
                                    // OSC: ESC ] ... ESC \
                                    if:
                                        eq n1 93
                                        then:
                                            set i add i 2;
                                            let mut done2 <bool> false;
                                            while and lt i n not done2:
                                                do:
                                                    let c2 <i32> load_u8 add s add 4 i;
                                                    if:
                                                        and and eq c2 27 lt add i 1 n eq load_u8 add s add 4 add i 1 92
                                                        then:
                                                            set i add i 2;
                                                            set done2 true;
                                                        else:
                                                            set i add i 1;
                                        else:
                                            set i add i 1;
                        else:
                            set i add i 1;
                else:
                    if:
                        lt b 128
                        then:
                            set i add i 1;
                            set w add w 1;
                        else:
                            if:
                                and not lt b 240 lt b 248
                                then:
                                    set i add i 4;
                                    set w add w 2;
                                else:
                                    if:
                                        and not lt b 224 lt b 240
                                        then:
                                            set i add i 3;
                                            set w add w 2;
                                        else:
                                            if:
                                                and not lt b 192 lt b 224
                                                then:
                                                    set i add i 2;
                                                    set w add w 2;
                                                else:
                                                    set i add i 1;
                                                    set w add w 1;
    w

//: line_pad_to_cols: 行文字列を指定表示幅まで右側空白で埋める
//:
//: [目的/もくてき]:
//: - 以前の長い行が残る問題を防ぎ、行更新を安定させます。
//:
//: [実装/じっそう]:
//: - `str_display_width` で現在幅を求め、足りない分だけ空白を連結します。
//:
//: [注意/ちゅうい]:
//: - 入力が指定幅を超える場合は切り詰めず、そのまま返します。
//:
//: [計算量/けいさんりょう]:
//: - O(n)
fn line_pad_to_cols <(str,i32)*>str> (s, cols):
    let w <i32> str_display_width s;
    if:
        lt w cols
        then:
            concat s repeat_text " " sub cols w
        else:
            s

//: line_clip_to_cols: 行文字列を指定表示幅以内に切り詰める
//:
//: [目的/もくてき]:
//: - 横幅制限がある領域へ安全に描画するため、表示幅ベースで文字列を切り詰めます。
//:
//: [実装/じっそう]:
//: - UTF-8 先頭バイトから 1文字ごとのバイト長と概算表示幅を求め、
//:   次の文字を追加すると `cols` を超える時点で切り出しを終了します。
//:
//: [注意/ちゅうい]:
//: - ANSI/OSC8 を含む文字列の厳密処理は対象外です（通常テキスト向け）。
//: - 幅計算は厳密な East Asian Width 判定ではなく近似です。
//:
//: [計算量/けいさんりょう]:
//: - O(n)
fn line_clip_to_cols <(str,i32)*>str> (s, cols):
    if:
        lt cols 1
        then:
            ""
        else:
            let n <i32> len s;
            let mut i <i32> 0;
            let mut w <i32> 0;
            while lt i n:
                do:
                    let b <i32> load_u8 add s add 4 i;
                    let ch_len <i32> if:
                        lt b 128
                        then 1
                        else:
                            if:
                                and not lt b 240 lt b 248
                                then 4
                                else:
                                    if:
                                        and not lt b 224 lt b 240
                                        then 3
                                        else:
                                            if:
                                                and not lt b 192 lt b 224
                                                then 2
                                                else 1;
                    let ch_w <i32> if lt b 128 1 2;
                    if:
                        lt cols add w ch_w
                        then:
                            set i n
                        else:
                            set w add w ch_w;
                            set i add i ch_len;
            str_slice s 0 i

//: text_wrap_lines: 表示幅で折り返した行配列を作る
//:
//: [目的/もくてき]:
//: - 長文を端末上で読みやすく表示するため、表示幅単位で複数行へ折り返します。
//:
//: [実装/じっそう]:
//: - 改行文字 `\n` を明示的な行区切りとして扱います。
//: - それ以外は UTF-8 先頭バイトから文字幅を推定し、`cols` を超える前で折り返します。
//:
//: [注意/ちゅうい]:
//: - 幅計算は近似です。結合文字や一部絵文字は端末依存差が出ます。
//: - `cols <= 0` の場合は空配列を返します。
//:
//: [計算量/けいさんりょう]:
//: - O(n)
fn text_wrap_lines <(str,i32)*>Vec<str>> (text, cols):
    let mut out <Vec<str>> vec_new<str>;
    if:
        lt cols 1
        then:
            out
        else:
            let n <i32> len text;
            let mut i <i32> 0;
            let mut line_start <i32> 0;
            let mut line_w <i32> 0;
            while lt i n:
                do:
                    let b <i32> load_u8 add text add 4 i;
                    if:
                        eq b 10
                        then:
                            let ln <str> str_slice text line_start i;
                            set out vec_push<str> out ln;
                            set i add i 1;
                            set line_start i;
                            set line_w 0;
                        else:
                            let ch_len <i32> if:
                                lt b 128
                                then 1
                                else:
                                    if:
                                        and not lt b 240 lt b 248
                                        then 4
                                        else:
                                            if:
                                                and not lt b 224 lt b 240
                                                then 3
                                                else:
                                                    if:
                                                        and not lt b 192 lt b 224
                                                        then 2
                                                        else 1;
                            let ch_w <i32> if lt b 128 1 2;
                            if:
                                lt cols add line_w ch_w
                                then:
                                    if:
                                        eq i line_start
                                        then:
                                            let ln2 <str> str_slice text line_start add i ch_len;
                                            set out vec_push<str> out ln2;
                                            set i add i ch_len;
                                            set line_start i;
                                            set line_w 0;
                                        else:
                                            let ln3 <str> str_slice text line_start i;
                                            set out vec_push<str> out ln3;
                                            set line_start i;
                                            set line_w 0;
                                else:
                                    set i add i ch_len;
                                    set line_w add line_w ch_w;
            let tail <str> str_slice text line_start n;
            set out vec_push<str> out tail;
            out

//: buffer_set_wrapped_text: 折り返し文字列を行バッファへ描画する
//:
//: [目的/もくてき]:
//: - 指定矩形（開始行と高さ）に、表示幅ベースで折り返したテキストを描画します。
//:
//: [実装/じっそう]:
//: - `text_wrap_lines` で行配列を作成し、上から順に `buffer_set_line` で反映します。
//: - 各行は `line_clip_to_cols` と `line_pad_to_cols` を通し、幅を安定化します。
//: - 高さを超える分は切り捨て、不足行は空白行を入れて残像を防ぎます。
//:
//: [注意/ちゅうい]:
//: - 行番号は 1-origin です。
//: - 文字色/背景色は、この関数に渡す前に `style_text` で付与してください。
//:
//: [計算量/けいさんりょう]:
//: - O(n + h) （n: テキスト長, h: 描画高さ）
fn buffer_set_wrapped_text <(i32,i32,i32,i32,str)*>()> (b, start_row, cols, height, text):
    if:
        and gt height 0 gt cols 0
        then:
            let n <i32> len text;
            let mut i <i32> 0;
            let mut line_start <i32> 0;
            let mut line_w <i32> 0;
            let mut row_i <i32> 0;
            while and lt i n lt row_i height:
                do:
                    let row <i32> add start_row row_i;
                    let b0 <i32> load_u8 add text add 4 i;
                    if:
                        eq b0 10
                        then:
                            let s0 <str> str_slice text line_start i;
                            let s0c <str> line_clip_to_cols s0 cols;
                            let s0p <str> line_pad_to_cols s0c cols;
                            buffer_set_line b row s0p;
                            set i add i 1;
                            set line_start i;
                            set line_w 0;
                            set row_i add row_i 1;
                        else:
                            let ch_len <i32> if:
                                lt b0 128
                                then 1
                                else:
                                    if:
                                        and not lt b0 240 lt b0 248
                                        then 4
                                        else:
                                            if:
                                                and not lt b0 224 lt b0 240
                                                then 3
                                                else:
                                                    if:
                                                        and not lt b0 192 lt b0 224
                                                        then 2
                                                        else 1;
                            let ch_w <i32> if lt b0 128 1 2;
                            if:
                                lt cols add line_w ch_w
                                then:
                                    if:
                                        eq i line_start
                                        then:
                                            let s1 <str> str_slice text line_start add i ch_len;
                                            let s1c <str> line_clip_to_cols s1 cols;
                                            let s1p <str> line_pad_to_cols s1c cols;
                                            buffer_set_line b row s1p;
                                            set i add i ch_len;
                                            set line_start i;
                                            set line_w 0;
                                            set row_i add row_i 1;
                                        else:
                                            let s2 <str> str_slice text line_start i;
                                            let s2c <str> line_clip_to_cols s2 cols;
                                            let s2p <str> line_pad_to_cols s2c cols;
                                            buffer_set_line b row s2p;
                                            set line_start i;
                                            set line_w 0;
                                            set row_i add row_i 1;
                                else:
                                    set i add i ch_len;
                                    set line_w add line_w ch_w;
            if:
                lt row_i height
                then:
                    let row2 <i32> add start_row row_i;
                    let s3 <str> str_slice text line_start n;
                    let s3c <str> line_clip_to_cols s3 cols;
                    let s3p <str> line_pad_to_cols s3c cols;
                    buffer_set_line b row2 s3p;
                    set row_i add row_i 1;
                else:
                    ();
            while lt row_i height:
                do:
                    buffer_set_line b add start_row row_i line_pad_to_cols "" cols;
                    set row_i add row_i 1;
        else:
            ();
    ()

//: line_box: 罫線付きの1行（`│ ... │`）を作る
//:
//: [目的/もくてき]:
//: - 枠線付きUIの行構築を簡潔に行います。
//:
//: [実装/じっそう]:
//: - 内側幅 `cols-2` に合わせて `content` を右パディングし、両端に縦罫線を付けます。
//:
//: [注意/ちゅうい]:
//: - `cols < 2` のケースは呼び出し側で回避してください。
fn line_box <(str,i32)*>str> (content, cols):
    let inner <i32> sub cols 2;
    let body <str> line_pad_to_cols content inner;
    concat3 "│" body "│"

//: line_box_styled: 罫線付きの1行を色付き背景で作る
//:
//: [目的/もくてき]:
//: - 行全体の背景色を確実に塗りたい場合に使います。
//:
//: [実装/じっそう]:
//: - 先に `content` を内側幅までパディングし、その結果全体に `style_text` を適用します。
//:
//: [注意/ちゅうい]:
//: - 罫線（`│`）自体は無色です。内側領域のみ色がつきます。
fn line_box_styled <(i32,i32,str,i32)*>str> (fg, bg, content, cols):
    let inner <i32> sub cols 2;
    let body <str> line_pad_to_cols content inner;
    let styled <str> style_text fg bg body;
    concat3 "│" styled "│"

//: line_top: 上枠（`┌──┐`）を作る
//:
//: [目的/もくてき]:
//: - ボックス描画の先頭行を生成します。
fn line_top <(i32)*>str> (cols):
    concat3 "┌" repeat_text "─" sub cols 2 "┐"

//: line_bottom: 下枠（`└──┘`）を作る
//:
//: [目的/もくてき]:
//: - ボックス描画の最終行を生成します。
fn line_bottom <(i32)*>str> (cols):
    concat3 "└" repeat_text "─" sub cols 2 "┘"

//: style_text: 前景色/背景色を付与した文字列を作る
//:
//: [目的/もくてき]:
//: - 文字列単位で色付けし、差分レンダリング行に埋め込めるようにします。
//:
//: [実装/じっそう]:
//: - `ESC[<fg>;<bg>m` を前置し、末尾に `ESC[0m` を付加します。
//:
//: [注意/ちゅうい]:
//: - `fg`,`bg` は 0..7（ANSI標準色）を前提とします。
//: - 色シーケンス自体は `str_display_width` で幅0として扱われます。
fn style_text <(i32,i32,str)*>str> (fg, bg, s):
    let c1 <str> from_i32 add fg 30;
    let c2 <str> from_i32 add bg 40;
    let p0 <str> concat3 "\x1b[" c1 ";";
    let p1 <str> concat3 p0 c2 "m";
    let p2 <str> concat p1 s;
    concat p2 "\x1b[0m"

//: hyperlink_text: OSC8 でハイパーリンク付き文字列を作る
//:
//: [目的/もくてき]:
//: - 端末が対応している場合にクリック可能なリンクを表示します。
//:
//: [実装/じっそう]:
//: - `ESC]8;;urlESC\\` + `text` + `ESC]8;;ESC\\` を連結します。
//:
//: [注意/ちゅうい]:
//: - OSC8 非対応端末ではリンクとして機能しません。
fn hyperlink_text <(str,str)*>str> (url, text):
    let open <str> concat3 "\x1b]8;;" url "\x1b\\";
    let close <str> "\x1b]8;;\x1b\\";
    let t <str> concat open text;
    concat t close

//: ---- 行バッファ差分レンダリング ----
//:
//: Buffer レイアウト:
//: - +0  : cols (i32)
//: - +4  : rows (i32)
//: - +8  : curr_lines_ptr (i32)  // i32[row] (str ポインタ)
//: - +12 : prev_lines_ptr (i32)  // i32[row] (str ポインタ)

//: buffer_new: 行バッファを作成する
//:
//: [目的/もくてき]:
//: - 差分レンダリングのための `curr`/`prev` 行配列を初期化します。
//:
//: [実装/じっそう]:
//: - 行数ぶんの `str` ポインタ配列を2面確保し、空文字列で初期化します。
//:
//: [注意/ちゅうい]:
//: - 返り値は `buffer_free` で解放してください。
fn buffer_new <(i32,i32)*>i32> (cols, rows):
    let curr <i32> alloc mul rows 4;
    let prev <i32> alloc mul rows 4;
    let mut i <i32> 0;
    while lt i rows:
        do:
            store_i32 add curr mul i 4 "";
            store_i32 add prev mul i 4 "";
            set i add i 1;
    let b <i32> alloc 16;
    store_i32 b cols;
    store_i32 add b 4 rows;
    store_i32 add b 8 curr;
    store_i32 add b 12 prev;
    b

//: buffer_free: 行バッファを解放する
//:
//: [目的/もくてき]:
//: - `buffer_new` で確保したメモリを解放します。
fn buffer_free <(i32)*>()> (b):
    let rows <i32> load_i32 add b 4;
    let curr <i32> load_i32 add b 8;
    let prev <i32> load_i32 add b 12;
    dealloc curr mul rows 4;
    dealloc prev mul rows 4;
    dealloc b 16;
    ()

//: buffer_set_line: row(1-origin) の行文字列を設定する
//:
//: [目的/もくてき]:
//: - 次フレームの行内容を `curr` 側へ登録します。
//:
//: [注意/ちゅうい]:
//: - 行番号が範囲外の場合は何もしません。
fn buffer_set_line <(i32,i32,str)*>()> (b, row, line):
    let rows <i32> load_i32 add b 4;
    if:
        and gt row 0 lt row add rows 1
        then:
            let curr <i32> load_i32 add b 8;
            store_i32 add curr mul sub row 1 4 line;
        else:
            ();
    ()

//: line_has_escape: 行に ESC 制御文字が含まれるか判定する
//:
//: [目的/もくてき]:
//: - 文字単位差分時に、ANSI/OSC8 を含む行を安全に全行更新へフォールバックするために使います。
fn line_has_escape <(str)*>bool> (s):
    let n <i32> len s;
    let mut i <i32> 0;
    let mut found <bool> false;
    while and lt i n not found:
        do:
            if:
                eq load_u8 add s add 4 i 27
                then:
                    set found true
                else:
                    ();
            set i add i 1;
    found

//: buffer_present_diff: 差分のある行だけ再描画する
//:
//: [目的/もくてき]:
//: - `curr` と `prev` を比較し、変更行のみ端末へ出力します。
//: - 同一行内では先頭差分位置から末尾のみを書き換え、更新量を削減します。
//:
//: [実装/じっそう]:
//: - まず `str_eq` で同一行を判定します。
//: - 差分行では「最初に異なるバイト位置」を求め、そこから行末までを再描画します。
//: - ANSI/OSC8 を含む行は安全性のため行全体更新にフォールバックします。
//: - 描画後は該当行の `prev` を更新します。
//:
//: [注意/ちゅうい]:
//: - UTF-8 文字幅は `str_display_width` による近似です。
//: - 差分開始位置はバイト基準で探索し、カーソル列は表示幅換算で計算します。
fn buffer_present_diff <(i32)*>()> (b):
    let cols <i32> load_i32 b;
    let rows <i32> load_i32 add b 4;
    let curr <i32> load_i32 add b 8;
    let prev <i32> load_i32 add b 12;
    let mut i <i32> 0;
    while lt i rows:
        do:
            let c <str> load_i32 add curr mul i 4;
            let p <str> load_i32 add prev mul i 4;
            if:
                not str_eq c p
                then:
                    if:
                        or line_has_escape c line_has_escape p
                        then:
                            move_cursor 1 add i 1;
                            print line_pad_to_cols c cols;
                        else:
                            let lc <i32> len c;
                            let lp <i32> len p;
                            let minlen <i32> if lt lc lp lc lp;
                            let mut d <i32> 0;
                            let mut found <bool> false;
                            while and lt d minlen not found:
                                do:
                                    if:
                                        eq load_u8 add c add 4 d load_u8 add p add 4 d
                                        then:
                                            set d add d 1
                                        else:
                                            set found true;
                            let prefix <str> str_slice c 0 d;
                            let col0 <i32> add str_display_width prefix 1;
                            let tail <str> str_slice c d lc;
                            let remain_cols <i32> add sub cols col0 1;
                            move_cursor col0 add i 1;
                            print line_pad_to_cols tail remain_cols;
                    store_i32 add prev mul i 4 c;
                else:
                    ();
            set i add i 1;
    ()
