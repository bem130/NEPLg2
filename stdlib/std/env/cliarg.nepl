#indent 4

#if[target=wasm]
#extern "wasi_snapshot_preview1" "args_sizes_get" fn args_sizes_get <(i32,i32)*>i32>
#if[target=wasm]
#extern "wasi_snapshot_preview1" "args_get" fn args_get <(i32,i32)*>i32>
#if[target=llvm]
#extern "c" "syscall" fn __cli_syscall <(i64,i64,i64,i64,i64,i64,i64)*>i64>

#import "core/mem" as *
#import "core/math" as *
#import "core/option" as *

//: cliarg: コマンドライン引数取得（WASI / LLVM）
//:
//: 目的:
//: - `cliarg_count` / `cliarg_get` で argv を読み出します。
//:
//: 実装(アルゴリズム):
//: - wasm は WASI `args_sizes_get/args_get` を使います。
//: - llvm は Linux `/proc/self/cmdline` を syscall で読み、互換 `args_sizes_get/args_get` を実装します。
//: - NUL 終端の文字列を [len][bytes] 形式の str にコピーします。
//:
//: 注意(重要):
//: - WASI ターゲット専用です（wasm では使用できません）。
//: - 取得ごとにメモリを確保し、解放しません。
//: - argv[0] はプログラム名相当です。
//:
//: 計算量:
//: - 引数取得は O(total_bytes)

#if[target=llvm]
fn __cli_copy_to_cstr <(str)*>i32> (s):
    let len <i32> load_i32 s;
    let src <i32> add s 4;
    let dst <i32> alloc add len 1;
    let mut i <i32> 0;
    while lt i len:
        do:
            store_u8 add dst i load_u8 add src i;
            set i add i 1;
    store_u8 add dst len 0;
    dst

#if[target=llvm]
fn __cli_open_cmdline <()*>i32> ():
    let path <str> "/proc/self/cmdline";
    let cpath <i32> __cli_copy_to_cstr path;
    let fd64 <i64> __cli_syscall i64_extend_i32_u 257 i64_extend_i32_s -100 i64_extend_i32_u cpath i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0;
    if:
        cond:
            i64_lt_s fd64 i64_extend_i32_u 0
        then -1
        else i32_wrap_i64 fd64

#if[target=llvm]
fn __cli_read_cmdline <(i32,i32)*>i32> (buf, cap):
    let fd <i32> __cli_open_cmdline;
    if:
        cond:
            lt fd 0
        then:
            -1
        else:
            let n64 <i64> __cli_syscall i64_extend_i32_u 0 i64_extend_i32_u fd i64_extend_i32_u buf i64_extend_i32_u cap i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0;
            __cli_syscall i64_extend_i32_u 3 i64_extend_i32_u fd i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0 i64_extend_i32_u 0;
            if:
                cond:
                    i64_lt_s n64 i64_extend_i32_u 0
                then -1
                else i32_wrap_i64 n64

#if[target=llvm]
fn args_sizes_get <(i32,i32)*>i32> (argc_ptr, buf_ptr):
    let cap <i32> 65536;
    let tmp <i32> alloc cap;
    let n <i32> __cli_read_cmdline tmp cap;
    if:
        cond:
            lt n 0
        then:
            1
        else:
            let mut argc <i32> 0;
            let mut i <i32> 0;
            while lt i n:
                do:
                    if:
                        eq load_u8 add tmp i 0
                        then set argc add argc 1;
                        else ();
                    set i add i 1;
            store_i32 argc_ptr argc;
            store_i32 buf_ptr n;
            0

#if[target=llvm]
fn args_get <(i32,i32)*>i32> (argv_ptr, argv_buf):
    let cap <i32> 65536;
    let tmp <i32> alloc cap;
    let n <i32> __cli_read_cmdline tmp cap;
    if:
        cond:
            lt n 0
        then:
            1
        else:
            let mut i <i32> 0;
            while lt i n:
                do:
                    store_u8 add argv_buf i load_u8 add tmp i;
                    set i add i 1;

            let mut argi <i32> 0;
            if:
                cond:
                    lt 0 n
                then:
                    store_i32 argv_ptr argv_buf;
                else ();

            let mut j <i32> 0;
            while lt j n:
                do:
                    if:
                        eq load_u8 add argv_buf j 0
                        then:
                            set argi add argi 1;
                            if:
                                cond:
                                    lt add j 1 n
                                then:
                                    store_i32 add argv_ptr mul argi 4 add argv_buf add j 1;
                                else ();
                        else ();
                    set j add j 1;
            0

//: cstr_len: NUL 終端文字列の長さを求める
//:
//: 目的:
//: - p から NUL までのバイト数を返します。
//:
//: 実装(アルゴリズム):
//: - 1 バイトずつ読み、0 に達したら停止します。
//:
//: 注意(重要):
//: - 終端が無い場合は未定義です。
//:
//: 計算量:
//: - O(n)
//: cstr_len: 使い方の最小例
//:
//: [目的/もくてき]:
//: - `cstr_len` の典型的な使い方を最小構成で示します。
//: - 値を返す関数は結果の受け取り方も合わせて確認できます。
//:
//: [注意/ちゅうい]:
//: - 例は用途が伝わる最短の呼び出しに絞っています。
//: - 境界条件や詳細な正当性検証は専用テストで扱います。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/env/cliarg" as *
//: fn main <()*>()> ():
//:     cstr_len 0;
//: ```
fn cstr_len <(i32)*>i32> (p):
    let mut i <i32> 0
    let mut done <i32> 0
    while eq done 0:
        do:
            let b <i32> load_u8 add p i;
            if:
                cond:
                    eq b 0
                then:
                    set done 1;
                else:
                    set i add i 1;
    i

//: cstr_to_str: NUL 終端文字列を str にコピーする
//:
//: 目的:
//: - p から読み取った文字列を str として返します。
//:
//: 実装(アルゴリズム):
//: - cstr_len で長さを求め、len+4 を確保してコピーします。
//:
//: 注意(重要):
//: - 呼び出しごとに新しい領域を確保します。
//:
//: 計算量:
//: - O(n)
//: cstr_to_str: 使い方の最小例
//:
//: [目的/もくてき]:
//: - `cstr_to_str` の典型的な使い方を最小構成で示します。
//: - 値を返す関数は結果の受け取り方も合わせて確認できます。
//:
//: [注意/ちゅうい]:
//: - 例は用途が伝わる最短の呼び出しに絞っています。
//: - 境界条件や詳細な正当性検証は専用テストで扱います。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/env/cliarg" as *
//: fn main <()*>()> ():
//:     cstr_to_str 0;
//: ```
fn cstr_to_str <(i32)*>str> (p):
    let len <i32> cstr_len p
    let out <i32> alloc add 4 len
    store_i32 out len
    let mut i <i32> 0
    while lt i len:
        do:
            let b <i32> load_u8 add p i;
            store_u8 add out add 4 i b;
            set i add i 1;
    out

//: cliarg_count: 引数の個数を返す
//:
//: 目的:
//: - argc を返します（argv[0] を含みます）。
//:
//: 実装(アルゴリズム):
//: - args_sizes_get で argc を取得します。
//:
//: 注意(重要):
//: - 失敗時は 0 を返します。
//:
//: 計算量:
//: - O(1)
//: cliarg_count: 使い方の最小例
//:
//: [目的/もくてき]:
//: - `cliarg_count` の典型的な使い方を最小構成で示します。
//: - 値を返す関数は結果の受け取り方も合わせて確認できます。
//:
//: [注意/ちゅうい]:
//: - 例は用途が伝わる最短の呼び出しに絞っています。
//: - 境界条件や詳細な正当性検証は専用テストで扱います。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/env/cliarg" as *
//: fn main <()*>()> ():
//:     cliarg_count ();
//: ```
fn cliarg_count <()*>i32> ():
    let meta <i32> alloc 8
    let argc_ptr <i32> meta
    let buf_ptr <i32> add meta 4
    let errno <i32> args_sizes_get argc_ptr buf_ptr
    if:
        eq errno 0
        then:
            load_i32 argc_ptr
        else:
            0

//: cliarg_get: 指定 index の引数を取得する
//:
//: 目的:
//: - idx が範囲内なら Some(str)、範囲外なら None を返します。
//:
//: 実装(アルゴリズム):
//: - args_sizes_get/args_get を呼び出し、argv を取得します。
//: - argv[idx] を NUL 終端として読み取り、str にコピーします。
//:
//: 注意(重要):
//: - idx < 0 は None になります。
//: - 取得ごとにメモリを確保します。
//:
//: 計算量:
//: - O(total_bytes + len)
//: cliarg_get: 使い方の最小例
//:
//: [目的/もくてき]:
//: - `cliarg_get` の典型的な使い方を最小構成で示します。
//: - 値を返す関数は結果の受け取り方も合わせて確認できます。
//:
//: [注意/ちゅうい]:
//: - 例は用途が伝わる最短の呼び出しに絞っています。
//: - 境界条件や詳細な正当性検証は専用テストで扱います。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/env/cliarg" as *
//: fn main <()*>()> ():
//:     cliarg_get 0;
//: ```
fn cliarg_get <(i32)*>Option<str>> (idx):
    if:
        cond:
            lt idx 0
        then:
            none<str>
        else:
            let meta <i32> alloc 8
            let argc_ptr <i32> meta
            let buf_ptr <i32> add meta 4
            let errno <i32> args_sizes_get argc_ptr buf_ptr
            if:
                eq errno 0
                then:
                    let argc <i32> load_i32 argc_ptr
                    if:
                        cond:
                            lt idx argc
                        then:
                            let argv <i32> alloc mul argc 4
                            let buf_size <i32> load_i32 buf_ptr
                            let argv_buf <i32> alloc buf_size
                            let errno2 <i32> args_get argv argv_buf
                            if:
                                eq errno2 0
                                then:
                                    let offset <i32> mul idx 4
                                    let arg_ptr <i32> load_i32 add argv offset
                                    some<str> cstr_to_str arg_ptr
                                else:
                                    none<str>
                        else:
                            none<str>
                else:
                    none<str>

//: cliarg_program: argv[0] を返す
//:
//: 目的:
//: - プログラム名相当の引数を返します。
//:
//: 実装(アルゴリズム):
//: - cliarg_get 0 を呼びます。
//:
//: 注意(重要):
//: - 取得に失敗した場合は None です。
//:
//: 計算量:
//: - O(total_bytes + len)
//: cliarg_program: 使い方の最小例
//:
//: [目的/もくてき]:
//: - `cliarg_program` の典型的な使い方を最小構成で示します。
//: - 値を返す関数は結果の受け取り方も合わせて確認できます。
//:
//: [注意/ちゅうい]:
//: - 例は用途が伝わる最短の呼び出しに絞っています。
//: - 境界条件や詳細な正当性検証は専用テストで扱います。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/env/cliarg" as *
//: fn main <()*>()> ():
//:     cliarg_program ();
//: ```
fn cliarg_program <()*>Option<str>> ():
    cliarg_get 0
