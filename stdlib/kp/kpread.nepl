#indent 4
#target wasi
#import "core/mem" as *
#import "core/math" as *
#import "core/option" as *
#import "std/stdio" as *
#import "alloc/string" as *
#import "alloc/vec" as *

// kpread: fast scanner for competitive programming
//
// Purpose:
// - Read all stdin once, then parse space-separated tokens quickly.
// - Provide i32, N-length arrays, HxW matrices, and "read until EOF" helpers.
//
// Algorithm:
// - Use WASI fd_read in a loop to fill a growable heap buffer.
// - Keep a cursor (pos) and advance it while scanning.
//
// Notes:
// - The scanner keeps the whole input in memory (O(bytes)).
// - scanner_read_i32 assumes the next token is an integer token.
//   (If the next token is not an integer, it may return 0 without advancing.)
//   scanner_read_all_i32 is defensive and will skip non-integer tokens.
//
// Complexity:
// - Reading stdin: O(bytes)
// - Scanning: O(bytes)
// - Parsing one integer: O(digits)

// Scanner header layout (12 bytes on heap)
// - [0] buf_ptr: start of input buffer
// - [4] len:     buffer length
// - [8] pos:     current cursor

// scanner_new: read all stdin and build a scanner
//
// Purpose:
// - Read stdin fully and return a scanner handle (pointer).
//
// Algorithm:
// - Start with cap=65536. If full, grow to 2x and continue.
// - Call fd_read until it returns 0 bytes (EOF) or errno != 0.
// - Allocate a 12-byte header [buf,len,pos] and return it.
//
// Notes:
// - Return value is a pointer to the 12-byte scanner header.
// - This module does not provide a "free" API for the input buffer (can be added later).
//
// Complexity:
// - O(bytes)
fn scanner_new <()*>i32> ():
    let mut cap <i32> 65536;
    let mut buf <i32> alloc cap;
    let mut len <i32> 0;

    // Temporary objects for WASI fd_read
    let iov <i32> alloc 8;
    let nread_ptr <i32> alloc 4;

    let mut done <i32> 0;
    while eq done 0:
        do:
            if:
                eq len cap
                then:
                    let new_cap <i32> mul cap 2;
                    let new_buf <i32> realloc buf cap new_cap;
                    set buf new_buf;
                    set cap new_cap;
                else:
                    ()

            store_i32 iov add buf len;
            store_i32 add iov 4 sub cap len;
            store_i32 nread_ptr 0;

            let errno <i32> fd_read 0 iov 1 nread_ptr;
            if:
                ne errno 0
                then:
                    set done 1;
                else:
                    let n <i32> load_i32 nread_ptr;
                    if:
                        eq n 0
                        then:
                            set done 1;
                        else:
                            set len add len n;

    // Free temporaries; the main input buffer stays alive.
    dealloc iov 8;
    dealloc nread_ptr 4;

    let sc <i32> alloc 12;
    store_i32 sc buf;
    store_i32 add sc 4 len;
    store_i32 add sc 8 0;
    sc

// scanner_skip_ws: skip ASCII whitespace (and BOM at the start)
//
// Purpose:
// - Advance pos to the start of the next token.
//
// Algorithm:
// - When pos==0, detect and skip UTF-8 BOM (EF BB BF) or UTF-16 BOM (FF FE / FE FF).
// - Then skip NUL, space, tab, \n, and \r.
//
// Notes:
// - Only ASCII whitespace is handled; this is intentional for contest inputs.
// - NUL is treated as whitespace.
//
// Complexity:
// - O(skipped bytes)
fn scanner_skip_ws <(i32)*>()> (sc):
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;

    // BOM skip (kept for compatibility)
    if:
        eq p 0
        then:
            if:
                ge len 2
                then:
                    let b0 <i32> load_u8 buf;
                    let b1 <i32> load_u8 add buf 1;
                    if:
                        ge len 3
                        then:
                            let b2 <i32> load_u8 add buf 2;
                            // UTF-8 BOM: EF BB BF
                            if:
                                and and eq b0 239 eq b1 187 eq b2 191
                                then:
                                    set p 3;
                                else:
                                    // UTF-16 BOM: FF FE or FE FF
                                    if:
                                        or and eq b0 255 eq b1 254 and eq b0 254 eq b1 255
                                        then:
                                            set p 2;
                                        else:
                                            ()
                        else:
                            if:
                                or and eq b0 255 eq b1 254 and eq b0 254 eq b1 255
                                then:
                                    set p 2;
                                else:
                                    ()
                else:
                    ()
        else:
            ()

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    eq byte 0
                    then:
                        set p add p 1;
                    else:
                        if:
                            or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                            then:
                                set p add p 1;
                            else:
                                set done 1;
            else:
                set done 1;

    store_i32 add sc 8 p;
    ()

// scanner_is_eof: check whether no more tokens exist
//
// Purpose:
// - Return true if only whitespace remains.
//
// Algorithm:
// - Call scanner_skip_ws, then compare pos with len.
//
// Complexity:
// - O(skipped whitespace)
fn scanner_is_eof <(i32)*>bool> (sc):
    scanner_skip_ws sc;
    let len <i32> load_i32 add sc 4;
    let p <i32> load_i32 add sc 8;
    ge p len

// scanner_skip_token: consume one token without allocation
//
// Purpose:
// - Advance pos by one token (space-delimited) without creating a string.
// - Used to guarantee progress in scanner_read_all_i32.
//
// Algorithm:
// - Skip whitespace, then advance until next whitespace.
//
// Complexity:
// - O(token length)
fn scanner_skip_token <(i32)*>()> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                    then:
                        set done 1;
                    else:
                        set p add p 1;
            else:
                set done 1;

    store_i32 add sc 8 p;
    ()

// scanner_read_token: read the next token as a string
//
// Purpose:
// - Return the next space-delimited token as str.
//
// Algorithm:
// - Skip whitespace, find token end, then copy bytes into a new string allocation.
//
// Notes:
// - This allocates for every token; avoid for large inputs if you only need integers.
// - Returns "" on EOF.
//
// Complexity:
// - O(token length)
fn scanner_read_token <(i32)*>str> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let start <i32> load_i32 add sc 8;
    let mut p <i32> start;

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                    then:
                        set done 1;
                    else:
                        set p add p 1;
            else:
                set done 1;

    let tlen <i32> sub p start;
    if:
        eq tlen 0
        then:
            ""
        else:
            let s <i32> alloc add 4 tlen;
            store_i32 s tlen;
            let mut i <i32> 0;
            while lt i tlen:
                do:
                    store_u8 add s add 4 i load_u8 add buf add start i;
                    set i add i 1;
            store_i32 add sc 8 p;
            s

// scanner_read_i32: read the next token as i32 (signed decimal)
//
// Purpose:
// - Parse the next token as a base-10 signed integer.
//
// Algorithm:
// - Optional leading '-', then parse digits with val=val*10+digit.
//
// Notes:
// - If the next token is not an integer token, this can return 0 without advancing.
// - Returns 0 on EOF.
//
// Complexity:
// - O(digits)
fn scanner_read_i32 <(i32)*>i32> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;
    if:
        ge p len
        then:
            0
        else:
            let mut sign <i32> 1;
            let b0 <i32> load_u8 add buf p;
            if:
                eq b0 45
                then:
                    set sign -1;
                    set p add p 1;
                else:
                    ();

            let mut val <i32> 0;
            let mut done <i32> 0;
            while eq done 0:
                if:
                    lt p len
                    then:
                        let byte <i32> load_u8 add buf p;
                        if:
                            eq byte 0
                            then:
                                set p add p 1;
                            else:
                                if:
                                    and ge byte 48 le byte 57
                                    then:
                                        set val add mul val 10 sub byte 48;
                                        set p add p 1;
                                    else:
                                        set done 1;
                    else:
                        set done 1;

            store_i32 add sc 8 p;
            mul val sign

// scanner_read_vec_i32: read n i32 values
//
// Purpose:
// - Read n integers into Vec<i32>.
//
// Complexity:
// - O(n)
fn scanner_read_vec_i32 <(i32, i32)*>Vec<i32>> (sc, n):
    let mut v <Vec<i32>> vec_new<i32>;
    let mut i <i32> 0;
    while lt i n:
        do:
            set v vec_push<i32> v scanner_read_i32 sc;
            set i add i 1;
    v

// scanner_read_matrix_i32: read an h x w integer matrix
//
// Purpose:
// - Read h rows of w integers and return Vec<Vec<i32>>.
//
// Complexity:
// - O(h*w)
fn scanner_read_matrix_i32 <(i32, i32, i32)*>Vec<Vec<i32>>> (sc, h, w):
    let mut res <Vec<Vec<i32>>> vec_new<Vec<i32>>;
    let mut i <i32> 0;
    while lt i h:
        do:
            set res vec_push<Vec<i32>> res scanner_read_vec_i32 sc w;
            set i add i 1;
    res

// scanner_read_all_i32: read all remaining integer tokens until EOF
//
// Purpose:
// - From the current cursor, scan until EOF and collect integer tokens into Vec<i32>.
//
// Algorithm:
// - Skip whitespace. If EOF, stop.
// - If the next non-space byte is '-' or '0'..'9', read an integer.
// - Otherwise, skip one token to ensure progress (defensive).
//
// Notes:
// - Non-integer tokens are discarded.
//
// Complexity:
// - O(remaining bytes)
fn scanner_read_all_i32 <(i32)*>Vec<i32>> (sc):
    let mut out <Vec<i32>> vec_new<i32>;
    let mut done <i32> 0;

    while eq done 0:
        do:
            scanner_skip_ws sc;
            let buf <i32> load_i32 sc;
            let len <i32> load_i32 add sc 4;
            let p <i32> load_i32 add sc 8;

            if:
                ge p len
                then:
                    set done 1;
                else:
                    let b <i32> load_u8 add buf p;
                    if:
                        or eq b 45 and ge b 48 le b 57
                        then:
                            set out vec_push<i32> out scanner_read_i32 sc;
                        else:
                            // Not an integer token; consume it to guarantee progress.
                            scanner_skip_token sc;
                            ();

    out

// -------- "common contest input" helpers (A / L,R / H as Vec) --------

// NAInput: input in the form:
//   N
//   A1 A2 ... AN
struct NAInput:
    n <i32>
    a <Vec<i32>>

// IntervalQueriesInput: input in the form:
//   N Q
//   L1 R1
//   ...
//   LQ RQ
//
// Notes:
// - This is a common contest format for interval queries.
// - Q corresponds to M in many statements.
struct IntervalQueriesInput:
    n <i32>
    q <i32>
    left <Vec<i32>>
    right <Vec<i32>>

// QueryTuplesInput: input in the form:
//   N Q
//   x1_1 x1_2 ... x1_K
//   ...
//   xQ_1 xQ_2 ... xQ_K
//
// Notes:
// - Stores values in column-major order:
//     cols[c][i] is i-th tuple's c-th value.
// - This generalizes 2xQ (L,R) to 3xQ, 4xQ, ... naturally.
struct QueryTuplesInput:
    n <i32>
    q <i32>
    k <i32>
    cols <Vec<Vec<i32>>>

// NDRHInput: input in the form:
//   N D R
//   H1 H2 ... HN
struct NDRHInput:
    n <i32>
    d <i32>
    r <i32>
    h <Vec<i32>>



// scanner_read_na_i32: read (N, A[1..N])
//
// Purpose:
// - Read the "N then N integers" format and return A as Vec<i32>.
//
// Complexity:
// - O(n)
fn scanner_read_na_i32 <(i32)*>NAInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let a <Vec<i32>> scanner_read_vec_i32 sc n;
    NAInput n a

// scanner_read_nmlr_i32: read (N, M, L[1..M], R[1..M])
//
// Purpose:
// - Read M pairs and return L and R as separate vectors.
//
// Complexity:
// - O(m)
// scanner_read_interval_queries_i32: read (N, Q, left[1..Q], right[1..Q])
//
// Purpose:
// - Read Q intervals and return left/right endpoints as separate vectors.
//
// Complexity:
// - O(q)
fn scanner_read_interval_queries_i32 <(i32)*>IntervalQueriesInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let q <i32> scanner_read_i32 sc;

    let mut left <Vec<i32>> vec_new<i32>;
    let mut right <Vec<i32>> vec_new<i32>;

    let mut i <i32> 0;
    while lt i q:
        do:
            set left vec_push<i32> left scanner_read_i32 sc;
            set right vec_push<i32> right scanner_read_i32 sc;
            set i add i 1;

    IntervalQueriesInput n q left right


// scanner_read_query_tuples_i32: read (N, Q, K columns) as column vectors
//
// Purpose:
// - Read Q rows where each row has K integers.
// - Store the result as K columns (Vec<Vec<i32>>) for easy column access.
//
// Notes:
// - If you need L/R, call this with k=2 and take cols[0], cols[1].
// - For 3xQ, 4xQ, ... just pass k=3,4,...
//
// Complexity:
// - O(q * k)
fn scanner_read_query_tuples_i32 <(i32, i32)*>QueryTuplesInput> (sc, k):
    let n <i32> scanner_read_i32 sc;
    let q <i32> scanner_read_i32 sc;

    let mut cols <Vec<Vec<i32>>> vec_new<Vec<i32>>;

    // Initialize k empty columns
    let mut c0 <i32> 0;
    while lt c0 k:
        do:
            set cols vec_push<Vec<i32>> cols vec_new<i32>;
            set c0 add c0 1;

    // Fill columns
    let mut i <i32> 0;
    while lt i q:
        do:
            let mut c <i32> 0;
            while lt c k:
                do:
                    let x <i32> scanner_read_i32 sc;

                    // cols[c].push(x)
                    let col <Vec<i32>> unwrap<Vec<i32>> vec_get<Vec<i32>> cols c;
                    let new_col <Vec<i32>> vec_push<i32> col x;
                    vec_set<Vec<i32>> cols c new_col;

                    set c add c 1;

            set i add i 1;

    QueryTuplesInput n q k cols


// query_tuples_col_i32: get the c-th column from QueryTuplesInput
//
// Notes:
// - This returns the Vec<i32> stored in cols[c].
// - Index must satisfy 0 <= c < t.k.
fn query_tuples_col_i32 <(QueryTuplesInput, i32)->Vec<i32>> (t, c):
    unwrap<Vec<i32>> vec_get<Vec<i32>> t.cols c


// Backward-compatible name (was scanner_read_nmlr_i32 in older drafts)
//
// Notes:
// - Kept as a thin wrapper to avoid breaking existing solutions.
fn scanner_read_nmlr_i32 <(i32)*>IntervalQueriesInput> (sc):
    scanner_read_interval_queries_i32 sc


// scanner_read_ndrh_i32: read (N, D, R, H[1..N])
//
// Purpose:
// - Read the "N D R then N integers" format and return H as Vec<i32>.
//
// Complexity:
// - O(n)
fn scanner_read_ndrh_i32 <(i32)*>NDRHInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let d <i32> scanner_read_i32 sc;
    let r <i32> scanner_read_i32 sc;
    let h <Vec<i32>> scanner_read_vec_i32 sc n;
    NDRHInput n d r h
