#indent 4
#target wasix

#if[target=wasm]
#extern "wasi_snapshot_preview1" "path_open" fn wasi_path_open <(i32,i32,i32,i32,i32,i64,i64,i32,i32)*>i32>
#if[target=wasm]
#extern "wasi_snapshot_preview1" "fd_write" fn wasi_fd_write <(i32,i32,i32,i32)*>i32>
#if[target=wasm]
#extern "wasi_snapshot_preview1" "fd_read" fn wasi_fd_read <(i32,i32,i32,i32)*>i32>
#if[target=wasm]
#extern "wasi_snapshot_preview1" "fd_close" fn wasi_fd_close <(i32)*>i32>

#import "core/mem" as *
#import "alloc/string" as *

fn wasi_right_fd_read <()*>i64> ():
    i64_extend_i32_u 2

fn wasi_right_fd_write <()*>i64> ():
    i64_extend_i32_u 64

fn open_with_candidates <(str,i32,i64)*>i32> (path, oflags, rights):
    let pptr <i32> add path 4;
    let plen <i32> len path;
    let fd_out <i32> alloc 4;
    let mut fd <i32> -1;
    let mut cand <i32> 3;
    let mut done <bool> false;
    while and le cand 16 not done:
        do:
            store_i32 fd_out 0;
            let errno <i32> wasi_path_open cand 0 pptr plen oflags rights rights 0 fd_out;
            if:
                eq errno 0
                then:
                    set fd load_i32 fd_out;
                    set done true;
                else:
                    set cand add cand 1;
    fd

fn save_to_file <(str,str)*>bool> (path, content):
    let rights_base <i64> wasi_right_fd_write;
    let fd <i32> open_with_candidates path 9 rights_base;
    if:
        lt fd 0
        then:
            false
        else:
            let iov <i32> alloc 8;
            store_i32 iov add content 4;
            store_i32 add iov 4 len content;
            let nw <i32> alloc 4;
            store_i32 nw 0;
            let errno1 <i32> wasi_fd_write fd iov 1 nw;
            let _ <i32> wasi_fd_close fd;
            eq errno1 0

fn read_from_file_or <(str,str)*>str> (path, fallback):
    let rights_base <i64> wasi_right_fd_read;
    let fd <i32> open_with_candidates path 0 rights_base;
    if:
        lt fd 0
        then:
            fallback
        else:
            let cap <i32> 4096;
            let buf <i32> alloc cap;
            let iov <i32> alloc 8;
            store_i32 iov buf;
            store_i32 add iov 4 cap;
            let nr <i32> alloc 4;
            store_i32 nr 0;
            let errno1 <i32> wasi_fd_read fd iov 1 nr;
            let _ <i32> wasi_fd_close fd;
            if:
                ne errno1 0
                then:
                    fallback
                else:
                    let n <i32> load_i32 nr;
                    if:
                        le n 0
                        then:
                            ""
                        else:
                            let out <i32> alloc add 4 n;
                            store_i32 out n;
                            let mut i <i32> 0;
                            while lt i n:
                                do:
                                    store_u8 add out add 4 i load_u8 add buf i;
                                    set i add i 1;
                            out
