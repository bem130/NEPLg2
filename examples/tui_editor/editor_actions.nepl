#indent 4
#target wasix

#import "core/math" as *
#import "alloc/string" as *
#import "./editor_text" as et
#import "./editor_fs" as efs
#import "./editor_messages" as em

fn move_left <(i32)*>i32> (cursor):
    if:
        gt cursor 0
        then:
            sub cursor 1
        else:
            cursor

fn clamp_cursor <(str,i32)*>i32> (text, cursor):
    if:
        lt cursor 0
        then:
            0
        else:
            if:
                gt cursor len text
                then:
                    len text
                else:
                    cursor

fn move_right <(str,i32)*>i32> (text, cursor):
    let c <i32> clamp_cursor text cursor;
    if:
        lt c len text
        then:
            add c 1
        else:
            c

fn move_word_forward <(str,i32)*>i32> (text, cursor):
    let n <i32> len text;
    let mut i <i32> clamp_cursor text cursor;
    while and lt i n et::is_word_byte load_u8 add text add 4 i:
        do:
            set i add i 1;
    while and lt i n not et::is_word_byte load_u8 add text add 4 i:
        do:
            set i add i 1;
    i

fn move_word_backward <(str,i32)*>i32> (text, cursor):
    let mut i <i32> clamp_cursor text cursor;
    if:
        gt i 0
        then:
            set i sub i 1;
        else:
            ();
    while and gt i 0 not et::is_word_byte load_u8 add text add 4 i:
        do:
            set i sub i 1;
    while and gt i 0 et::is_word_byte load_u8 add text add 4 sub i 1:
        do:
            set i sub i 1;
    i

fn cursor_move_up <(str,i32)*>i32> (text, cursor):
    et::move_up text clamp_cursor text cursor

fn cursor_move_down <(str,i32)*>i32> (text, cursor):
    et::move_down text clamp_cursor text cursor

fn move_line_start <(str,i32)*>i32> (text, cursor):
    et::find_line_start text clamp_cursor text cursor

fn move_line_end <(str,i32)*>i32> (text, cursor):
    et::find_line_end text clamp_cursor text cursor

fn move_doc_start <(str)*>i32> (text):
    0

fn move_doc_end <(str)*>i32> (text):
    len text

fn apply_backspace_text <(str,i32)*>str> (text, cursor):
    let c <i32> clamp_cursor text cursor;
    if:
        gt c 0
        then:
            et::delete_before text c
        else:
            text

fn apply_backspace_cursor <(i32)*>i32> (cursor):
    if:
        gt cursor 0
        then:
            sub cursor 1
        else:
            cursor

fn apply_delete_at_text <(str,i32)*>str> (text, cursor):
    let c <i32> clamp_cursor text cursor;
    if:
        lt c len text
        then:
            let l <str> et::safe_slice text 0 c;
            let r <str> et::safe_slice text add c 1 len text;
            concat l r
        else:
            text

fn apply_insert_text <(str,i32,i32)*>str> (text, cursor, ch):
    et::insert_byte text clamp_cursor text cursor ch

fn apply_insert_cursor <(i32)*>i32> (cursor):
    add cursor 1

fn save_message <(str,str)*>str> (path, text):
    if:
        efs::save_to_file path text
        then:
            em::msg_saved
        else:
            em::msg_save_failed

fn run_message <()*>str> ():
    em::msg_run_hint

fn jump_cursor <(str,i32)*>i32> (text, cursor):
    let c <i32> clamp_cursor text cursor;
    let w <str> et::get_word_at text c;
    if:
        gt len w 0
        then:
            et::find_definition_cursor_from text w c
        else:
            c

fn jump_message <(str,i32)*>str> (text, cursor):
    let w <str> et::get_word_at text clamp_cursor text cursor;
    if:
        gt len w 0
        then:
            concat "jump: " w
        else:
            em::msg_no_word

fn type_message <(str,i32)*>str> (text, cursor):
    let w <str> et::get_word_at text clamp_cursor text cursor;
    if:
        gt len w 0
        then:
            concat "type: " w
        else:
            "type: (none)"
