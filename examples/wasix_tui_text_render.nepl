// wasix_tui_text_render.nepl
// テキストレンダリングデモ: 折り返し・クリップ・日本語幅の確認
//
// 実行: wasmer run examples/wasix_tui_text_render.wasm
#entry main
#indent 4
#target wasix

#import "std/stdio" as *
#import "core/math" as *
#import "core/field" as *
#import "platforms/wasix/tui" as tui

fn draw_text_demo <(i32,i32,i32,i32)*>()> (buf, cols, rows, frame):
    tui::buffer_set_line buf 1 tui::style_text 6 0 tui::line_top cols;
    tui::buffer_set_line buf 2 tui::line_box_styled 7 4 " WASIX TUI Text Rendering Demo " cols;

    let s0 <str> " Terminal: ";
    let s1 <str> concat s0 from_i32 cols;
    let s2 <str> concat s1 "x";
    let s3 <str> concat s2 from_i32 rows;
    let s4 <str> concat s3 "  Frame: ";
    let s5 <str> concat s4 from_i32 frame;
    tui::buffer_set_line buf 3 tui::line_box_styled 3 4 s5 cols;

    // 背景クリア
    let mut r <i32> 4;
    while lt r rows:
        do:
            tui::buffer_set_line buf r tui::line_box_styled 7 4 "" cols;
            set r add r 1;

    let area_w <i32> sub cols 4;
    let area_h <i32> sub rows 8;
    let t0 <str> "ASCII: The quick brown fox jumps over the lazy dog. ";
    let t1 <str> concat t0 "NUM: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
    let t2 <str> concat t1 "JP: 日本語の表示幅と折り返しを確認します。";
    let t3 <str> concat t2 " VERY_LONG_TOKEN_1234567890abcdefghijklmnopqrstuvwxyz";
    if:
        gt area_h 0
        then:
            tui::buffer_set_wrapped_text buf 5 area_w area_h t3
        else:
            ();

    let clip0 <str> "clip test: これは長いテキストです";
    let clip1 <str> tui::line_clip_to_cols clip0 20;
    let clip2 <str> concat " clip(20): " clip1;
    tui::buffer_set_line buf sub rows 2 tui::line_box_styled 0 2 clip2 cols;

    let url0 <str> "wasix.org";
    let h0 <str> tui::hyperlink_text url0 "WASIX";
    let h1 <str> concat " q: quit | rendering: wrap/clip/CJK width | " h0;
    tui::buffer_set_line buf rows tui::line_box_styled 0 2 h1 cols;

    tui::buffer_present_diff buf;
    ()

fn main <()*>()> ():
    let old <i32> tui::enter_raw_mode;
    if:
        ne old 0
        then:
            tui::hide_cursor;
            tui::clear_screen;

            let size0 <.Pair> tui::get_terminal_size;
            let mut cols <i32> get size0 0;
            let mut rows <i32> get size0 1;
            let mut buf <i32> tui::buffer_new cols rows;
            let mut frame <i32> 0;
            let mut quit <bool> false;

            while not quit:
                do:
                    let size <.Pair> tui::get_terminal_size;
                    let ncols <i32> get size 0;
                    let nrows <i32> get size 1;
                    if:
                        or ne ncols cols ne nrows rows
                        then:
                            tui::buffer_free buf;
                            set cols ncols;
                            set rows nrows;
                            set buf tui::buffer_new cols rows;
                            tui::clear_screen;
                        else:
                            ();

                    draw_text_demo buf cols rows frame;
                    set frame add frame 1;

                    let s <str> read_all;
                    if:
                        gt load_i32 s 0
                        then:
                            if:
                                eq load_u8 add s 4 113
                                then:
                                    set quit true
                                else:
                                    ();
                        else:
                            ();

            tui::show_cursor;
            tui::clear_screen;
            tui::buffer_free buf;
            tui::restore_mode old;
            println "Done!";
        else:
            println "Failed to enter raw mode.";
